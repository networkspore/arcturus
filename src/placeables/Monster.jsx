/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useMemo, useRef,useImperativeHandle, forwardRef, useEffect, useState } from 'react'
import { Skeleton, AmbientLight, Box3, BoxGeometry, Color, CylinderGeometry, Group, Material, Mesh, MeshBasicMaterial, MeshPhongMaterial, MeshStandardMaterial, Object3D, ShaderMaterial, Vector2, Vector3 } from 'three'
import { extend, useFrame, useThree } from '@react-three/fiber';
//import { DRACOLoader, GLTFLoader, IFFParser } from 'three-stdlib';
import useZust from '../hooks/useZust';
import { EffectComposer, RenderPass, UnrealBloomPass } from 'three-stdlib';
import { constants } from '../constants/constants';
import { isObject } from 'lodash';
import { fGlow, uGlow, vGlow } from '../pages/components/Shaders/GlowShader';
extend({ EffectComposer, RenderPass, UnrealBloomPass })

const Monster = (props = {}, ref) => {
  //const group = useRef()

  const loadedRef = useRef({gltf:false});
  
  const gltfRef = useRef({ gltf: {} })


  const { gl, camera, size, scene } = useThree()
  const effect = useRef();
  const bloomScene = useRef();
  const aspect = useMemo(() => new Vector2(size.width, size.height), [
    size
  ]);

  //const scene = useThree((state)=>state.scene)

  const assets = useZust((state) => state.assets);

  const editCampaign = useZust((state)=> state.editCampaign)
  const mode = useZust((state) => state.mode)
  const [geo, setGeo] = useState(null)
  const [selected, setSelected] = useState(null);

  const cloneGltf = (gltf) => {
    const clone = {
      animations: gltf.animations,
      scene: gltf.scene.clone(true)
    };

    const skinnedMeshes = {};

    gltf.scene.traverse(node => {
      if (node.isSkinnedMesh) {
        skinnedMeshes[node.name] = node;
      }
    });

    const cloneBones = {};
    const cloneSkinnedMeshes = {};

    clone.scene.traverse(node => {
      if (node.isBone) {
        cloneBones[node.name] = node;
      }

      if (node.isSkinnedMesh) {
        cloneSkinnedMeshes[node.name] = node;
      }
    });

    for (let name in skinnedMeshes) {
      const skinnedMesh = skinnedMeshes[name];
      const skeleton = skinnedMesh.skeleton;
      const cloneSkinnedMesh = cloneSkinnedMeshes[name];

      const orderedCloneBones = [];

      for (let i = 0; i < skeleton.bones.length; ++i) {
        const cloneBone = cloneBones[skeleton.bones[i].name];
        orderedCloneBones.push(cloneBone);
      }

      cloneSkinnedMesh.bind(
        new Skeleton(orderedCloneBones, skeleton.boneInverses),
        cloneSkinnedMesh.matrixWorld);
    }

    return clone;
  }

  useEffect(()=>{
    if (props.object != null) {

      if ("url" in props.object) {

        if (props.object.url in gltfRef.current.gltf) {
          
            scene.add(gltfRef.current.gltf[props.object.url].scene)
          }
      
      }
    }
    return () => {
      if (props.object != null) {

        if ("url" in props.object) {

          if (props.object.url in gltfRef.current.gltf) {
            const obj = gltfRef.current.gltf[props.object.url]
            
            scene.remove(obj.scene)
          }
        }
      }
         
    }
  },[])

  /*useEffect(()=>{
    if( props.object != undefined){
      const g = new Group();
      if(props.object != null) if(props.object.url !== undefined) if(props.object.url != props.object.url){
        if(scene.traverse((object)=>{
          if(object.name == properties.object.url){
            if(object.userData.id == properties.monsterSceneID){
              scene.remove(object)
            }
          }
        }))
        delete gltfRef.current.gltf[properties.object.url]
      }
      
      setProperties({
        monsterSceneID:props.monsterSceneID,
        object: props.object, 
        scale: props.scale
      })
    }
   
  },[props.object])*/

  const updateMonsterProperties = () =>{
    //alert(props.monsterSceneID)bloom
    gltfRef.current.gltf[props.object.url].scene.userData = {main:constants.MONSTER_MODE, sub:"", id:props.monsterSceneID }
    gltfRef.current.gltf[props.object.url].scene.name = props.object.url;

    gltfRef.current.gltf[props.object.url].scene.traverse((node)=>{
      if(node.isMesh){
        node.userData = {main:constants.MONSTER_MODE, sub:"", id:props.monsterSceneID}
        if(node.name == props.object.name){
          node.material.color = new Color(props.object.color)
        }
        node.scale.set(props.scale * props.object.scale.x, props.scale * props.object.scale.x, props.scale * props.object.scale.x)
        
        node.castShadow = true;
        node.receiveShadow = true;
        
      }else{
      
      }
    })
    if (props.object.position[0] != null){
      gltfRef.current.gltf[props.object.url].scene.position.set(
        props.object.position[0],
        props.object.position[1],
        props.object.position[2],
      )
    }else{
      gltfRef.current.gltf[props.object.url].scene.position.set(
        0, -10000000000, 0
      )
    }
  }
  //const [properties, setProperties] = useState({props:null, meshes:[]})

  useEffect(()=>{
    
    if (props.object !== undefined) {
      if (props.object.url !== undefined) {

        if (!(props.object.url in gltfRef.current.gltf) && props.object.url in assets.gltfs){
          if (assets.gltfs[props.object.url] != null){
            
              const gltf = cloneGltf(assets.gltfs[props.object.url])
              gltfRef.current.gltf[props.object.url] = gltf;
              updateMonsterProperties();
      
         
           scene.add(gltfRef.current.gltf[props.object.url].scene)
                        
          }
        } else if (props.object.url in gltfRef.current.gltf) {
          updateMonsterProperties();
        }
      }
    }
  
    
  },[assets, props])
  const [hovered, setHovered] =useState(false)
  
  useEffect(() => {
    if (editCampaign.mode == constants.HOVER_MONSTER && editCampaign.settings.value == props.monsterSceneID){
     if(hovered == false) setHovered(true)
    
    }else{
      if(hovered) setHovered(false);
    }
  }, [editCampaign])


useEffect(()=>{
  if (mode.main == constants.MONSTER_MODE && mode.id == props.monsterSceneID){
      setSelected(true)
     
  }else if(selected)
  {
    setSelected(false)
  }
},[mode])
const triangleRef = useRef({mesh:null});
useEffect(()=>{
  if(selected == true){
    
    if(triangleRef.current.mesh == null){
      const geometry = new CylinderGeometry(0,.3,.56,4,1)
      const material = new MeshPhongMaterial({color:"red"})
      const pyramid = new Mesh(geometry, material);
      pyramid.userData = {mode:"selection"}
      
      const box = new Box3().setFromObject(gltfRef.current.gltf[props.object.url].scene)
      const size = box.getSize(new Vector3());
      pyramid.position.set(0, size.y + .5, 0);
      pyramid.rotation.set(180 * (2 * Math.PI / 360),0,0);
      triangleRef.current.mesh = pyramid;
    }
    

    
    triangleRef.current.mesh.visible = true;
    gltfRef.current.gltf[props.object.url].scene.add(triangleRef.current.mesh);
  }else if(selected == false){
   
     if (gltfRef.current.gltf != null){
       if (props.object.url in gltfRef.current.gltf){
         if(triangleRef.current.mesh != null){
           triangleRef.current.mesh.visible = false;
         }
      }
    }
   
  
  }
},[selected])


  useEffect(()=>{
    if (props.object !== undefined) {
      if (props.object.url !== undefined) {

        if ((props.object.url in gltfRef.current.gltf) ) {
          

    if(hovered){
   
      gltfRef.current.gltf[props.object.url].scene.traverse((node) => {
        if (node.isMesh) {
          if (node.name == props.object.name) {
           
            setGeo(node.geometry)
           // node.opacity = .5
            const renderPass = new RenderPass(bloomScene.current, camera)
            const bloomPass = new UnrealBloomPass(aspect, 10,.9,.0001);
            effect.current = { composer: new EffectComposer(gl) }
            effect.current.composer.setSize = (aspect.width / 100, aspect.height / 100);
            effect.current.composer.addPass(renderPass);
            effect.current.composer.addPass(bloomPass);
            
          }
      

        }
      })
    }else if(hovered == false){
      effect.current = { composer: null }
    /*  bloomScene.current.traverse((node) => {
        if (node.isMesh) {
          bloomScene.current.remove(node);
         
        }
      })*/
    // 
  }
}
      }
    }
  },[hovered,aspect,bloomScene])

 useFrame(({clock})=>{
   if (effect.current != undefined) {
     if (effect.current.composer != null) {
       if (bloomScene.current != null)
      if(hovered){
       gl.clear();
       effect.current.composer.render(clock.getDelta())
        //  composer.current.render();
      gl.clearDepth();

      gl.render(scene, camera);
     }}
   }  
 })
  /*
  useImperativeHandle(
    ref,
    () => (
      group.current

    ));
*/
  //const { nodes, materials } = useGLTF(src)
  return (
     <>
     {hovered &&
      <scene ref={bloomScene} >
          <pointLight position-x={props.object.position[0]} position-y={props.object.position[1] +2} position-z={props.object.position[2]} intensity={.5} ></pointLight>
          <mesh userData={{main:constants.MONSTER_MODE, sub:"", id:props.monsterSceneID}} scale={props.scale * props.object.scale.x * 1.02}  position={props.object.position} castShadow={true} receiveShadow={true} geometry={geo} >
            <meshStandardMaterial attach="material" transparent opacity={.05} color={"white"} />
          </mesh>
   
        </scene>
    }
    
     </>
  
  )
}


export default Monster;


/*   <group ref={group}  {...props} dispose={null}>
      <mesh  castShadow={true} receiveShadow={true} geometry={nodes[name].geometry} >
        <meshStandardMaterial color={color} />
        </mesh>
        
    
    </group>*/
